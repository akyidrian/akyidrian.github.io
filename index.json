[{"content":"Since earning my EEE degree in 2013, I\u0026rsquo;ve been amazed by the revolution in hardware prototyping driven by Arduino and Raspberry Pi. These platforms have democratised electronics, making them accessible to beginners. Equally fascinating is the evolution of JavaScript, which has grown from merely allowing the creation of dynamic web pages to enabling direct hardware control. Many of these now-commonplace tools were unavailable during my studies, making me envious of today\u0026rsquo;s newcomers, yet excited for the rapid technological advancements to come.\nDuring the NodeBots Workshop at Conf \u0026amp; Coffee 2018, I had the opportunity to revisit the basics and experiment with the open-source Johnny-Five platform using an Arduino Uno. Johnny-Five, a Node.js library, facilitates JS programming for a wide range of development boards, with a focus on robotics and IoT applications. It relies on the Firmata protocol to communicate with microcontrollers, and offers compatibility with custom boards too.\nGetting Started Let\u0026rsquo;s explore some of Johnny-Five\u0026rsquo;s capabilities by first creating a simple LED blinking program:\nvar five = require(\u0026#39;johnny-five\u0026#39;); var board = new five.Board(); board.on(\u0026#39;ready\u0026#39;, function () { var led = new five.Led(13); led.blink(1000); // in ms }); As you can see, minimal code is required!\nIn addition to basic output control, Johnny-Five makes it easy to handle asynchronous events from various inputs. For example, here\u0026rsquo;s how you can toggle an LED using a button press:\nvar five = require(\u0026#39;johnny-five\u0026#39;); var board = new five.Board(); board.on(\u0026#39;ready\u0026#39;, function () { var led = new five.Led(13); var button = new five.Button(5); button.on(\u0026#34;press\u0026#34;, function() { led.toggle(); }); }); You can also utilise Johnny-Five for sensor inputs, such as a photoresistor:\nvar five = require(\u0026#39;johnny-five\u0026#39;); var board = new five.Board(); board.on(\u0026#39;ready\u0026#39;, function () { var led = new five.Led(13); var sensor = new five.Sensor(\u0026#34;A0\u0026#34;); sensor.on(\u0026#34;change\u0026#34;, function() { if(this.value \u0026gt; 600) { led.on(); } else { led.off(); } }); }); These simple examples demonstrate the ease of integrating hardware input-output with Johnny-Five. At no point did we need to write code for the round-robin loop, tune the loop frequency, configure data direction registers or mask the right pins with bit manipulation.\nClient-Server Interaction One surprising feature of Johnny-Five for me was its ability to create client-server scenarios effortlessly. For instance, you can set up a UDP client using Node.js on your developer machine to communicate with an Arduino server via USB:\nvar dgram = require(\u0026#39;dgram\u0026#39;); var client = dgram.createSocket(\u0026#39;udp4\u0026#39;); // Send empty datagrams over port 1337 client.send(\u0026#34;\u0026#34;, 1337, \u0026#39;localhost\u0026#39;, function(err) { console.error(\u0026#34;Failed to send. Is your Arduino running \u0026#39;server.js\u0026#39;?\\n\u0026#34;); client.close(); }); On the Arduino side, you can create a server to respond to incoming datagrams or trigger actions, such as playing a tune over a connected piezo speaker:\nvar dgram = require(\u0026#39;dgram\u0026#39;); var five = require(\u0026#39;johnny-five\u0026#39;); var board = new five.Board(); board.on(\u0026#39;ready\u0026#39;, function () { var piezo = new five.Piezo(8); var server = dgram.createSocket(\u0026#39;udp4\u0026#39;); server.on(\u0026#39;message\u0026#39;, function() { piezo.play({ song: [ [\u0026#34;C4\u0026#34;, 1 / 4], [\u0026#34;D4\u0026#34;, 1 / 4], [\u0026#34;F4\u0026#34;, 1 / 4], [\u0026#34;D4\u0026#34;, 1 / 4], [\u0026#34;A4\u0026#34;, 1 / 4], [null, 1 / 4], [\u0026#34;A4\u0026#34;, 1], [\u0026#34;G4\u0026#34;, 1], [null, 1 / 2], [\u0026#34;C4\u0026#34;, 1 / 4], [\u0026#34;D4\u0026#34;, 1 / 4], [\u0026#34;F4\u0026#34;, 1 / 4], [\u0026#34;D4\u0026#34;, 1 / 4], [\u0026#34;G4\u0026#34;, 1 / 4], [null, 1 / 4], [\u0026#34;G4\u0026#34;, 1], [\u0026#34;F4\u0026#34;, 1], [null, 1 / 2] ], tempo: 100 }); }); server.bind(1337); }); On a similar note, I experimented with dnode, an asynchronous RPC system for Node.js that facilitates remote function calls. A client, running on a developer\u0026rsquo;s machine, connects to a server and calls a remote getTemperature function:\nvar dnode = require(\u0026#39;dnode\u0026#39;); var d = dnode.connect(1337); d.on(\u0026#39;remote\u0026#39;, function(remote) { remote.getTemperature(function(t) { console.log(\u0026#34;Temperature is: \u0026#34; + t + \u0026#34;\\n\u0026#34;); d.end(); }); }); On the Arduino server, a temp variable is continuously updated with the latest temperature from a connected sensor. The server also handles remote calls to its getTemperature function, executing the console.log callback provided by the client. Here\u0026rsquo;s the server code:\nvar dnode = require(\u0026#39;dnode\u0026#39;); var five = require(\u0026#39;johnny-five\u0026#39;); var board = new five.Board(); board.on(\u0026#39;ready\u0026#39;, function () { var therm = new five.Thermometer({ controller: \u0026#34;TMP36\u0026#34;, pin: \u0026#34;A0\u0026#34;, }); var temp = null; therm.on(\u0026#34;change\u0026#34;, function() { temp = this.C; }); var server = dnode({ getTemperature: function(cb) { cb(temp); } }); server.listen(1337); }); These two examples, one with UDP sockets and the other with RPC, showcases the versatility of Johnny-Five in facilitating client-server communication for interactive hardware applications.\nDebugging with Console When debugging Arduino projects, the REPL (Read-Eval-Print Loop) proves to be a valuable tool. It facilitates seamless communication between your Arduino device and the Node.js terminal on your computer, enabling you to send and receive debug commands and messages. Let\u0026rsquo;s dive into an example of using the REPL to control an LED and log the result:\nvar five = require(\u0026#34;johnny-five\u0026#34;); var board = new five.Board(); board.on(\u0026#34;ready\u0026#34;, function() { var led = new five.Led(13); this.repl.inject({ // Allow limited on/off control access to the LED instance from the REPL. on: function() { led.on(); console.log(\u0026#34;LED is on\u0026#34;); }, off: function() { led.off(); console.log(\u0026#34;LED is off\u0026#34;); } }); }); Executing the following commands in your Node.js terminal will turn the LED on and then off:\n\u0026gt; on() LED is on \u0026gt; off() LED is off While this example may seem trivial, it effectively showcases the power of real-time logging and interactive code execution of your Arduino from your terminal, and the ease in setting it all up.\nClosing I hope this summary provides a glimpse into the capabilities of Johnny-Five. With its user-friendly interface, it serves as an ideal platform for swiftly prototyping and implementing projects. If you\u0026rsquo;re feeling inspired, feel free to explore my workshop code.\n","permalink":"https://akyidrian.github.io/posts/2018-04-23-electronics-and-javascript-actually-do-mix/","summary":"My First Impressions of the Johnny-Five Platform","title":"Electronics and JavaScript Actually Do Mix"},{"content":"Since its humble beginnings at NetScape in 1995, JavaScript (JS) has evolved far beyond its original purpose of making web pages dynamic. ECMAScript (ES), the standard for JS, has seen numerous updates. Yet, many peculiarities from its early days persist and have become defining features of the language.\nRecently, during a talk at Conf \u0026amp; Coffee 2018, I was reminded of some of the quirky aspects of JS that I\u0026rsquo;ve fallen prey to in the past. For newcomers, these oddities can be frustrating, especially given the language itself is preventing you from solving the problem at hand. Coming from a C/C++ background, truthy / falsy values, logical operators, scope and objects were especially perplexing.\nTruthy and Falsy Values A truthy value is any value considered true in a Boolean context (such as within an if-statement). Conversely, a falsy value is any value considered false in a Boolean context. The tricky part of working with truthy and falsy values in JS is understanding the implicit type conversion (type coercion) performed on non-Boolean values.\nTo avoid confusion, remember that the following values are falsy in JS:\nfalse 0 null undefined \u0026#39;\u0026#39; \u0026#34;\u0026#34; NaN Therefore, anything else must be truthy. Some examples of truthy values include:\ntrue \u0026#34;true\u0026#34; \u0026#34;false\u0026#34; \u0026#34;1\u0026#34; \u0026#34;0\u0026#34; \u0026#34;-1\u0026#34; 1 -1 1.62 -1.62 Infinity -Infinity {} [] function(){} new Date() Logical Operators Logical operators add another layer of complexity in JS due to the nuances of data types and their interactions. This complexity can lead to unexpected behavior, especially when dealing with truthy and falsy values.\nConsider the following examples:\n// These seem consistent... false == 0 // true false == \u0026#34;\u0026#34; // true 0 == \u0026#34;\u0026#34; // true // These are not so consistent... false == null // false false == undefined // false null == undefined // true // This is common in other languages too, but easily be confused... false == NaN // false NaN == NaN // false // Interesting behaviour around [], {} and strings... false == [] // true false == [0] // true false == [[]] // true false == {} // false [] == {} // false false == \u0026#34;0\u0026#34; // true false == \u0026#34;false\u0026#34; // false For a more comprehensive table of equality comparisons, go here.\nTo avoid the variability shown above, you can use the !! unary operator to explicitly convert values to true or false:\nfalse == !!null // true false == !!undefined // true false == !!NaN // true false == !![] // false false == !!\u0026#34;0\u0026#34; // false However, a more robust solution is to use strict equality operators (=== and !==). These operators compare both value and type, reducing errors that stem from JS\u0026rsquo;s dynamic typing:\nfalse === null // false false === undefined // false false === NaN // false false === [] // false false === \u0026#34;0\u0026#34; // false Using strict equality helps prevent bugs caused by type coercion, making your code more predictable and easier to maintain. It also ensures that you and others can understand the intended logic without ambiguity.\nOn the topic of data types, JS has seven data types. Six of these are primitives:\nBoolean Null Undefined Number String Symbol (introduced in ECMAScript 6) The seventh data type is Object. Understanding the differences between these types is crucial for writing robust JS.\nScope When transitioning from languages like C to JS, understanding variable scope can be challenging. In C, variables declared within a set of curly brackets {} are confined to that scope. However, in JS, this can be less straightforward, especially when using the var keyword. In JS, variables declared with var are function-scoped, not block-scoped. This can lead to unexpected behavior:\nfor(var i = 0; i \u0026lt; 10; i++) {} console.log(i); // 10 if(true) { var i = 20; var i = 30; } console.log(i); // 30 In the above code, the variable i is accessible outside the for-loop and if-statement, which might not be what you expect.\nFurthermore, if you declare a variable without any keyword, it becomes global (assuming strict mode is not enabled). In the following code, local is confined to the function scope, but global becomes a global variable.\nfunction globalisation() { var local = 3.14; global = \u0026#39;global\u0026#39;; } To avoid these pitfalls, it\u0026rsquo;s best to use let and const for variable declarations. These keywords bind variables to block scope, preventing unintentional global declarations and re-declarations.\nlet allows variables to be block-scoped and reassigned, but not redeclared within the same scope:\nfor(let i = 0; i \u0026lt; 10; i++) {} console.log(i); // ReferenceError: i is not defined if(true) { let i = 20; i = 10; console.log(i); // 10 let i = 30; // SyntaxError: Identifier \u0026#39;i\u0026#39; has already been declared } const is similar to let, but the variable cannot be reassigned:\nif(true) { const i = 20; i = 10; // TypeError: Assignment to constant variable const i = 30; // SyntaxError: Identifier \u0026#39;i\u0026#39; has already been declared } console.log(i); // ReferenceError: i is not defined In conclusion, always use let and const to ensure variables are scoped appropriately and to avoid common errors associated with var and implicit globals. This practice will lead to more predictable and maintainable code.\nObjects JS objects come with a host of interesting and tricky aspects. One of the first big realisations for beginners is that JS is a prototype-based language language. Another surprising feature is the ability to add properties to objects after they are declared.\nconst cat = { name: \u0026#39;Mavi\u0026#39;, breed: \u0026#39;Birman\u0026#39;, meow: function() { return \u0026#34;Meow! I\u0026#39;m \u0026#34; + this.name + \u0026#34; and I\u0026#39;m a \u0026#34; + this.breed + \u0026#34; cat.\u0026#34;; } } cat.eyeColor = \u0026#39;blue\u0026#39;; While this flexibility is powerful, it can be dangerous if a developer makes incorrect assumptions about the existence of an object property, or simply makes a typo in attempting to reassign a value to an existing property. To safeguard against such issues, you can use Object.freeze:\nconst aWellBehavedCat = Object.freeze(cat); Note that adding a property to a frozen object will only throw an error in strict mode. However, freezing an object prevents accidental modification, ensuring the integrity of your data.\nFurther Exploration JS has many more fascinating concepts such as hoisting, closures, destructuring and various methods for creating objects. These topics have become essential knowledge for modern JS development. While I\u0026rsquo;ll save a deeper dive into these for another day, they\u0026rsquo;re definitely worth exploring on your own.\n","permalink":"https://akyidrian.github.io/posts/2018-04-22-javascript-is-weird/","summary":"My Summary about Truthy / Falsy Values, Logical Operators, Scope and Objects","title":"JavaScript is Weird"},{"content":"Over the weekend, I had the pleasure of attending Conf \u0026amp; Coffee 2018 at the Unbounce office in Vancouver, BC. Organized by the Code \u0026amp; Coffee Meetup group, this conference catered to programmers with a love for caffeine. The event saw a diverse mix of professionals and students, with a noticeable inclination towards mobile and web development.\nTechnical talks and workshops covered a wide range of languages, frameworks, and platforms, including React, NodeJS, JavaScript, Ruby, CSS, Elm, Elixir, Haskell, Python, Arduino, Raspberry Pi, Johnny-Five, and Toccata. Additionally, discussions spanned higher-level topics such as blockchain, data infrastructure, functional programming, software development, leadership, mentorship, project management and coffee (of course). For a detailed conference breakdown, check out the conference schedule, with additional resources available here.\nMy experience at the conference left me feeling enriched and enlightened, particularly after immersing myself in workshops rather than talks. Here are my top five takeaways:\nEngineers and the software systems they create are inherently coupled, necessitating a holistic consideration of both JavaScript is weird Electronics and JavaScript actually do mix I need to learn functional programming to be a great programmer Leadership skills are invaluable, regardless of one\u0026rsquo;s position within an organization ","permalink":"https://akyidrian.github.io/posts/2018-04-21-conf-and-coffee-2018/","summary":"A Brief Conference Summary","title":"Conf \u0026 Coffee 2018"},{"content":"Welcome to my blog!\nThe primary purpose of my blog is to document my research, studies, and projects, and to help me organise, clarify and crystallise my thoughts. You\u0026rsquo;ll find a wide array of topics covered here, including but not limited to computer science, programming, computer / software engineering, mathematics and investing. Through my writing, I also hope to connect and learn from others like yourself, so please comment and share your thoughts!\nHere\u0026rsquo;s something to ponder: At first glance, many problems may seem dauntingly complex or even insurmountable. Yet, with perseverance, we often uncover simple, ordered and explainable patterns that lead to solutions. I\u0026rsquo;m Aydin Arik, and I invite you to join me on this journey of discovery and learning!\n","permalink":"https://akyidrian.github.io/posts/2018-04-02-hello-friend/","summary":"First Blog Post","title":"Hello Friend"}]